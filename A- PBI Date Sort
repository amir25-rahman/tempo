
-- STEP 1: Get column names first
-- Replace 'your_table_name' with your actual table name

-- For MySQL:
DESCRIBE your_table_name;

-- For PostgreSQL:
-- \d your_table_name

-- For SQL Server:
-- SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'your_table_name';

-- For SQLite:
-- PRAGMA table_info(your_table_name);

-- =============================================================================
-- STEP 2: Dynamic query generation using INFORMATION_SCHEMA (PostgreSQL/MySQL/SQL Server)
-- =============================================================================

-- First, run this query to generate the UNION ALL statements:
SELECT 
    CONCAT(
        'SELECT ''', COLUMN_NAME, ''' as column_name, ',
        'COUNT(*) as total_count, ',
        'COUNT(', COLUMN_NAME, ') as non_null_count, ',
        'COUNT(*) - COUNT(', COLUMN_NAME, ') as null_count, ',
        'COUNT(DISTINCT ', COLUMN_NAME, ') as unique_count, ',
        'COUNT(', COLUMN_NAME, ') - COUNT(DISTINCT ', COLUMN_NAME, ') as duplicate_count ',
        'FROM your_table_name'
    ) as query_part
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_NAME = 'your_table_name'
  AND TABLE_SCHEMA = 'your_database_name'  -- Add this line if needed
ORDER BY ORDINAL_POSITION;

-- =============================================================================
-- STEP 3: Complete dynamic analysis query (PostgreSQL example)
-- =============================================================================

WITH column_stats AS (
    SELECT 
        column_name,
        total_count,
        non_null_count,
        null_count,
        unique_count,
        duplicate_count
    FROM (
        -- This part needs to be built dynamically from the results above
        -- Example for a table with columns: id, name, email, age
        SELECT 'id' as column_name, 
               COUNT(*) as total_count,
               COUNT(id) as non_null_count,
               COUNT(*) - COUNT(id) as null_count,
               COUNT(DISTINCT id) as unique_count,
               COUNT(id) - COUNT(DISTINCT id) as duplicate_count
        FROM your_table_name
        
        UNION ALL
        
        SELECT 'name' as column_name,
               COUNT(*) as total_count,
               COUNT(name) as non_null_count,
               COUNT(*) - COUNT(name) as null_count,
               COUNT(DISTINCT name) as unique_count,
               COUNT(name) - COUNT(DISTINCT name) as duplicate_count
        FROM your_table_name
        
        UNION ALL
        
        SELECT 'email' as column_name,
               COUNT(*) as total_count,
               COUNT(email) as non_null_count,
               COUNT(*) - COUNT(email) as null_count,
               COUNT(DISTINCT email) as unique_count,
               COUNT(email) - COUNT(DISTINCT email) as duplicate_count
        FROM your_table_name
        
        UNION ALL
        
        SELECT 'age' as column_name,
               COUNT(*) as total_count,
               COUNT(age) as non_null_count,
               COUNT(*) - COUNT(age) as null_count,
               COUNT(DISTINCT age) as unique_count,
               COUNT(age) - COUNT(DISTINCT age) as duplicate_count
        FROM your_table_name
    ) stats
)
SELECT 
    column_name,
    total_count,
    null_count,
    non_null_count,
    unique_count,
    duplicate_count,
    ROUND((null_count::numeric / total_count * 100), 2) as null_percentage,
    ROUND((unique_count::numeric / NULLIF(non_null_count, 0) * 100), 2) as unique_percentage,
    ROUND((duplicate_count::numeric / NULLIF(non_null_count, 0) * 100), 2) as duplicate_percentage
FROM column_stats
ORDER BY column_name;

-- =============================================================================
-- ALTERNATIVE: One-shot query generator for PostgreSQL
-- =============================================================================

-- Run this to get the complete query as a string that you can then execute:
SELECT 
    'WITH column_stats AS (' || CHR(10) ||
    STRING_AGG(
        'SELECT ''' || column_name || ''' as column_name, ' ||
        'COUNT(*) as total_count, ' ||
        'COUNT(' || column_name || ') as non_null_count, ' ||
        'COUNT(*) - COUNT(' || column_name || ') as null_count, ' ||
        'COUNT(DISTINCT ' || column_name || ') as unique_count, ' ||
        'COUNT(' || column_name || ') - COUNT(DISTINCT ' || column_name || ') as duplicate_count ' ||
        'FROM your_table_name',
        CHR(10) || 'UNION ALL' || CHR(10)
        ORDER BY ordinal_position
    ) || CHR(10) ||
    ') SELECT column_name, total_count, null_count, non_null_count, unique_count, duplicate_count, ' ||
    'ROUND((null_count::numeric / total_count * 100), 2) as null_percentage, ' ||
    'ROUND((unique_count::numeric / NULLIF(non_null_count, 0) * 100), 2) as unique_percentage, ' ||
    'ROUND((duplicate_count::numeric / NULLIF(non_null_count, 0) * 100), 2) as duplicate_percentage ' ||
    'FROM column_stats ORDER BY column_name;' as complete_query
FROM information_schema.columns 
WHERE table_name = 'your_table_name'
  AND table_schema = 'your_schema_name';  -- Replace with your schema









WITH column_info AS (
    SELECT 
        column_name, 
        data_type
    FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'your_table'
),
metrics AS (
    SELECT
        col.column_name,
        col.data_type,
        (SELECT COUNT(*) FROM your_table WHERE t.(col.column_name)::text IS NULL) AS null_count,
        (SELECT COUNT(DISTINCT t.(col.column_name)::text) FROM your_table t) AS unique_count,
        (SELECT COUNT(*) - COUNT(DISTINCT t.(col.column_name)::text) FROM your_table t) AS repeated_count,
        CASE 
            WHEN col.data_type IN ('text', 'varchar', 'char') THEN
                (SELECT SUM(LENGTH(t.(col.column_name)::text) 
                            - LENGTH(REGEXP_REPLACE(t.(col.column_name)::text, '[^A-Za-z0-9]', '', 'g')))
                 FROM your_table t
                 WHERE t.(col.column_name)::text IS NOT NULL)
            ELSE NULL
        END AS special_char_count
    FROM column_info col
)
SELECT * FROM metrics;

















-- Total row count
SELECT COUNT(*) AS total_rows FROM your_table;

-- Null count and percentage
SELECT 
    COUNT(*) AS total_rows,
    COUNT(your_column) AS non_nulls,
    COUNT(*) - COUNT(your_column) AS null_count,
    ROUND(100.0 * (COUNT(*) - COUNT(your_column)) / COUNT(*), 2) AS null_percent
FROM your_table;

-- Duplicate percentage
SELECT 
    COUNT(*) AS total_rows,
    COUNT(DISTINCT your_column) AS unique_values,
    COUNT(*) - COUNT(DISTINCT your_column) AS duplicate_count,
    ROUND(100.0 * (COUNT(*) - COUNT(DISTINCT your_column)) / COUNT(*), 2) AS duplicate_percent
FROM your_table
WHERE your_column IS NOT NULL;

-- Unique percentage
SELECT 
    ROUND(100.0 * COUNT(DISTINCT your_column) / COUNT(*), 2) AS unique_percent
FROM your_table
WHERE your_column IS NOT NULL;

-- Special character count
SELECT 
    COUNT(*) AS total_rows,
    SUM(CASE 
            WHEN your_column REGEXP '[^a-zA-Z0-9]' THEN 1 
            ELSE 0 
        END) AS special_char_count
FROM your_table
WHERE your_column IS NOT NULL;




-- Replace 'your_table' with your actual table name

WITH total_rows AS (
    SELECT COUNT(*) AS total FROM your_table
),
column_stats AS (
    SELECT
        'column_name' AS column_name,
        pg_typeof(column_name)::text AS data_type,
        COUNT(*) AS non_null_count,
        COUNT(DISTINCT column_name) AS unique_count,
        COUNT(*) - COUNT(DISTINCT column_name) AS duplicate_count,
        SUM(CASE WHEN column_name IS NULL THEN 1 ELSE 0 END) AS null_count,
        SUM(CASE WHEN column_name ~ '[^a-zA-Z0-9]' THEN 1 ELSE 0 END) AS special_char_count
    FROM your_table, total_rows
)
SELECT
    column_name,
    data_type,
    total,
    ROUND(100.0 * duplicate_count / total, 2) AS duplicate_percent,
    null_count,
    ROUND(100.0 * null_count / total, 2) AS null_percent,
    special_char_count,
    ROUND(100.0 * unique_count / total, 2) AS unique_percent
FROM column_stats, total_rows;







WorkWeekGroup = 
VAR CurrentDate = Sheet1[Dates]

-- Check if current date is a workday (Mon-Fri and NOT holiday)
VAR IsWorkday =
    WEEKDAY(CurrentDate, 2) <= 5 &&
    NOT(CONTAINS(Holidays, Holidays[Date], CurrentDate))

-- Get the Monday of the current week (Monday = 1)
VAR WeekStart =
    CurrentDate - WEEKDAY(CurrentDate, 2) + 1

-- Get the Friday of the current week
VAR WeekEnd = WeekStart + 4

RETURN
IF(
    IsWorkday,
    FORMAT(WeekStart, "mmm d") & " - " & FORMAT(WeekEnd, "mmm d"),
    BLANK()
)





Holidays = DATATABLE(
    "Date", DATETIME,
    {
        { "2025-01-01" },  // New Year's Day
        { "2025-01-20" },  // Martin Luther King Jr. Day
        { "2025-02-17" },  // Presidents' Day
        { "2025-05-26" },  // Memorial Day
        { "2025-06-19" },  // Juneteenth
        { "2025-07-04" },  // Independence Day
        { "2025-09-01" },  // Labor Day
        { "2025-10-13" },  // Columbus Day
        { "2025-11-11" },  // Veterans Day
        { "2025-11-27" },  // Thanksgiving Day
        { "2025-12-25" }   // Christmas Day
    }
)

