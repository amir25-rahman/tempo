import pandas as pd
import numpy as np

# Sample data
df = pd.DataFrame({
    'ID': range(1, 13),
    'Variable': ['A'] * 3 + ['B'] * 3 + ['C'] * 3 + ['D'] * 3,
    'Start_Time': pd.to_datetime([
        '2025-06-27 08:00', '2025-06-27 08:05', '2025-06-27 08:10',
        '2025-06-27 08:00', '2025-06-27 08:05', '2025-06-27 08:10',
        '2025-06-27 08:00', '2025-06-27 08:05', '2025-06-27 08:10',
        '2025-06-27 08:00', '2025-06-27 08:05', '2025-06-27 08:10'
    ])
})

# Ensure ordering
group_order = sorted(df['Variable'].unique())
df['Variable'] = pd.Categorical(df['Variable'], categories=group_order, ordered=True)
df.sort_values(by=['Variable', 'Start_Time'], inplace=True)

# Add random delay per row
np.random.seed(42)  # for reproducibility
df['Row_Delay'] = np.random.randint(5, 16, size=len(df))

# Initialize tracking
adjusted_times = []
previous_group_max_time = None

# Process group by group
for group in group_order:
    group_df = df[df['Variable'] == group].copy()
    
    new_times = []
    for idx, row in group_df.iterrows():
        base_time = row['Start_Time'] + pd.Timedelta(minutes=row['Row_Delay'])
        
        # Ensure it's after the previous group's max
        if previous_group_max_time and base_time < previous_group_max_time:
            base_time = previous_group_max_time + pd.Timedelta(minutes=1)  # at least 1 min later
        
        new_times.append(base_time)
        previous_group_max_time = max(previous_group_max_time or base_time, base_time)
    
    adjusted_times.extend(new_times)

df['New_Time'] = adjusted_times

print(df[['ID', 'Variable', 'Start_Time', 'Row_Delay', 'New_Time']])
